/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect, useCallback } from 'react'
import { useLoader, useThree, useFrame } from 'react-three-fiber'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import { useBox, useSphere, usePointToPointConstraint, } from 'use-cannon'

export default function Model(props) {
  const [cube, api] = useBox(() => ({
    mass : 1,
    args:[2,2,2],
    position: [0, 1, -18.74]
  }))

  const [cursor, apiCursor] = useSphere(()=> ({
    mass : 0,
    type : 'static'
  }));

  const [, , contApi] = usePointToPointConstraint(cursor, cube, { pivotA: [0, 0, 0], pivotB: [0, 0, 0] })
  contApi.disable();

  const {mouse, raycaster} = useThree()

  useFrame((e) => {
    console.log(e);
    
    const x = (e.mouse.x *10) / e.camera.zoom ;
    const y = (e.mouse.y * 10 ) /e.camera.zoom;
    apiCursor.position.set(x , y, 0)
  })

  const { nodes, materials } = useLoader(GLTFLoader, '/obstacle.gltf')
  return (
    <group  {...props} dispose={null}>
      <mesh  ref={cube} material={nodes.obstacle.material} geometry={nodes.obstacle.geometry} 
      onPointerDown={(e) => {
        //console.log(e.pageX);
        //console.log(cube.current.getWorldPosition());
        e.stopPropagation();
        e.target.setPointerCapture(e.pointerId)
        apiCursor.position.set(e.point.x,e.point.y,e.point.z)

        contApi.enable()        
      }} 
      onPointerUp ={(e) => {
        contApi.disable()
      } }
      onPointerMove= {(e) => {
      }} />

      
      <mesh ref={cursor}>
        <sphereBufferGeometry attach="geometry" args={[0.5, 32, 32]} />
        <meshBasicMaterial attach="material" fog={false} depthTest={false} color="crimson" />
      </mesh>
    </group>
  )
}
